{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.3\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n// Polyfill the following DOM methods that are not supported in IE 11.\n\n(() => {\n  function append(...nodes) {\n    const length = nodes.length;\n    for (let i = 0; i < length; i++) {\n      const node = nodes[i];\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\n    }\n  }\n  function replaceChildren(...nodes) {\n    while (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n    if (nodes.length) this.append(...nodes);\n  }\n  function replaceWith(...nodes) {\n    const parent = this.parentNode;\n    let i = nodes.length;\n    if (!parent) return;\n    if (!i) parent.removeChild(this);\n    while (i--) {\n      let node = nodes[i];\n      if (typeof node !== 'object') {\n        node = this.ownerDocument.createTextNode(node);\n      } else if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n      if (!i) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(this.previousSibling, node);\n      }\n    }\n  }\n  if (typeof Element !== 'undefined') {\n    if (!Element.prototype.append) {\n      Element.prototype.append = append;\n      DocumentFragment.prototype.append = append;\n    }\n    if (!Element.prototype.replaceChildren) {\n      Element.prototype.replaceChildren = replaceChildren;\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\n    }\n    if (!Element.prototype.replaceWith) {\n      Element.prototype.replaceWith = replaceWith;\n      DocumentFragment.prototype.replaceWith = replaceWith;\n    }\n  }\n})();\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce((extended, key) => {\n    const currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    const newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings(settings = {}) {\n  const object = extend(settings); // `split` may be used as an alias for the `types` option\n  // Parse the `types` settings into an array of valid split types.\n  // If `types` is explicitly set to an empty string or array, text will not be\n  // split at all.\n\n  let types;\n  if (object.types !== undefined) {\n    types = object.types;\n  } else if (object.split !== undefined) {\n    types = object.split;\n  }\n  if (types !== undefined) {\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(type => String(type).trim()).filter(type => /((line)|(word)|(char))/i.test(type));\n  } // Support `position: absolute` as an alias for `absolute: true`\n\n  if (object.absolute || object.position) {\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n  return object;\n}\n\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  const types = isString(value) || isArray(value) ? String(value) : '';\n  return {\n    none: !types,\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /char/i.test(types)\n  };\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */\n\nfunction getTargetElements(target) {\n  let elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  } // Return a flattened array of elements\n\n  return toArray(elements).reduce((result, element) => {\n    return [...result, ...toArray(element).filter(isNode)];\n  }, []);\n}\nconst {\n  entries,\n  keys,\n  values\n} = Object;\nconst expando = `_splittype`;\nconst cache = {};\nlet uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */\n\nfunction set(owner, key, value) {\n  if (!isObject(owner)) {\n    console.warn('[data.set] owner is not an object');\n    return null;\n  }\n  const id = owner[expando] || (owner[expando] = ++uid);\n  const data = cache[id] || (cache[id] = {});\n  if (value === undefined) {\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n      cache[id] = {\n        ...data,\n        ...key\n      };\n    }\n  } else if (key !== undefined) {\n    data[key] = value;\n  }\n  return value;\n}\nfunction get(owner, key) {\n  const id = isObject(owner) ? owner[expando] : null;\n  const data = id && cache[id] || {};\n  if (key === undefined) {\n    return data;\n  }\n  return data[key];\n}\n/**\n * Remove all data associated with the given element\n */\n\nfunction remove(element) {\n  const id = element && element[expando];\n  if (id) {\n    delete element[id];\n    delete cache[id];\n  }\n}\n/**\n * Remove all temporary data from the store.\n */\n\nfunction cleanup() {\n  entries(cache).forEach(([id, {\n    isRoot,\n    isSplit\n  }]) => {\n    if (!isRoot || !isSplit) {\n      cache[id] = null;\n      delete cache[id];\n    }\n  });\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(value, separator = ' ') {\n  const string = value ? String(value) : '';\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\n/** Used to compose unicode capture groups. */\n\nconst rsAstral = `[${rsAstralRange}]`;\nconst rsCombo = `[${rsComboMarksRange}${rsComboSymbolsRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsZWJ = '\\\\u200d';\n/** Used to compose unicode regexes. */\n\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsSymbol = `(?:${[`${rsNonAstral}${rsCombo}?`, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')}\n)`;\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol}${rsSeq}`, 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nconst unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nconst reHasUnicode = RegExp(`[${unicodeRange.join('')}]`);\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('f😀o');\n * // => ['f', '😀', 'o']\n *\n * toChars('f-😀-o', /-/);\n * // => ['f', '😀', 'o']\n *\n */\n\nfunction toChars(string, separator = '') {\n  string = toString(string);\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  const element = document.createElement(name);\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n  Object.keys(attributes).forEach(attribute => {\n    const rawValue = attributes[attribute];\n    const value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n\n    if (value === null || value === '') return;\n    if (attribute === 'children') {\n      // Children can be one or more Elements or DOM strings\n      element.append(...toArray(value));\n    } else {\n      // Handle standard HTML attributes\n      element.setAttribute(attribute, value);\n    }\n  });\n  return element;\n}\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: ['lines', 'words', 'chars'],\n  absolute: false,\n  tagName: 'div'\n};\n\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */\n\nfunction splitWordsAndChars(textNode, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  const types = parseTypes(settings.types); // the tag name for split text nodes\n\n  const TAG_NAME = settings.tagName; // value of the text node\n\n  const VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n\n  const splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n\n  let words = [];\n  let chars = [];\n  if (/^\\s/.test(VALUE)) {\n    splitText.append(' ');\n  } // Create an array of wrapped word elements.\n\n  words = toWords(VALUE).reduce((result, WORD, idx, arr) => {\n    // Let `wordElement` be the wrapped element for the current word\n    let wordElement;\n    let characterElementsForCurrentWord; // -> If splitting text into characters...\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      characterElementsForCurrentWord = toChars(WORD).map(CHAR => {\n        const characterElement = createElement(TAG_NAME, {\n          class: `${settings.splitClass} ${settings.charClass}`,\n          style: 'display: inline-block;',\n          children: CHAR\n        });\n        set(characterElement, 'isChar', true);\n        chars = [...chars, characterElement];\n        return characterElement;\n      });\n    } // END IF;\n\n    if (types.words || types.lines) {\n      // -> If Splitting Text Into Words...\n      //    Create an element to wrap the current word. If we are also\n      //    splitting text into characters, the word element will contain the\n      //    wrapped character nodes for this word. If not, it will contain the\n      //    plain text content (WORD)\n      wordElement = createElement(TAG_NAME, {\n        class: `${settings.wordClass} ${settings.splitClass}`,\n        style: `display: inline-block; ${types.words && settings.absolute ? `position: relative;` : ''}`,\n        children: types.chars ? characterElementsForCurrentWord : WORD\n      });\n      set(wordElement, {\n        isWord: true,\n        isWordStart: true,\n        isWordEnd: true\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // -> If NOT splitting into words OR lines...\n      //    Append the characters elements directly to splitText.\n      characterElementsForCurrentWord.forEach(characterElement => {\n        splitText.appendChild(characterElement);\n      });\n    }\n    if (idx < arr.length - 1) {\n      // Add a space after the word.\n      splitText.append(' ');\n    } // If not splitting text into words, we return an empty array\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // END LOOP;\n  // Add a trailing white space to maintain word spacing\n\n  if (/\\s$/.test(VALUE)) {\n    splitText.append(' ');\n  }\n  textNode.replaceWith(splitText);\n  return {\n    words,\n    chars\n  };\n}\n\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */\n\nfunction split(node, settings) {\n  const type = node.nodeType; // Arrays of split words and characters\n\n  const wordsAndChars = {\n    words: [],\n    chars: []\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n\n  if (!/(1|3|11)/.test(type)) {\n    return wordsAndChars;\n  } // A) IF `node` is TextNode that contains characters other than white space...\n  //    Split the text content of the node into words and/or characters\n  //    return an object containing the split word and character elements\n\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\n    return splitWordsAndChars(node, settings);\n  } // B) ELSE `node` is an 'Element'\n  //    Iterate through its child nodes, calling the `split` function\n  //    recursively for each child node.\n\n  const childNodes = toArray(node.childNodes);\n  if (childNodes.length) {\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\n\n    if (!get(node).isRoot) {\n      node.style.display = 'inline-block';\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\n      // splitting text into lines, we need to check if the element should\n      // have a space before and after, and store that value for later.\n      // Note: this was necessary to maintain the correct spacing when nested\n      // elements do not align with word boundaries. For example, a nested\n      // element only wraps part of a word.\n\n      const nextSibling = node.nextSibling;\n      const prevSibling = node.previousSibling;\n      const text = node.textContent || '';\n      const textAfter = nextSibling ? nextSibling.textContent : ' ';\n      const textBefore = prevSibling ? prevSibling.textContent : ' ';\n      set(node, {\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n      });\n    }\n  } // Iterate through child nodes, calling `split` recursively\n  // Returns an object containing all split words and chars\n\n  return childNodes.reduce((result, child) => {\n    const {\n      words,\n      chars\n    } = split(child, settings);\n    return {\n      words: [...result.words, ...words],\n      chars: [...result.chars, ...chars]\n    };\n  }, wordsAndChars);\n}\n\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */\nfunction getPosition(node, isWord, settings, scrollPos) {\n  if (!settings.absolute) {\n    return {\n      top: isWord ? node.offsetTop : null\n    };\n  }\n  const parent = node.offsetParent;\n  const [scrollX, scrollY] = scrollPos;\n  let parentX = 0;\n  let parentY = 0;\n  if (parent && parent !== document.body) {\n    const parentRect = parent.getBoundingClientRect();\n    parentX = parentRect.x + scrollX;\n    parentY = parentRect.y + scrollY;\n  }\n  const {\n    width,\n    height,\n    x,\n    y\n  } = node.getBoundingClientRect();\n  const top = y + scrollY - parentY;\n  const left = x + scrollX - parentX;\n  return {\n    width,\n    height,\n    top,\n    left\n  };\n}\n\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */\n\nfunction unSplitWords(element) {\n  if (!get(element).isWord) {\n    toArray(element.children).forEach(child => unSplitWords(child));\n  } else {\n    remove(element);\n    element.replaceWith(...element.childNodes);\n  }\n}\nconst createFragment = () => document.createDocumentFragment();\nfunction repositionAfterSplit(element, settings, scrollPos) {\n  const types = parseTypes(settings.types);\n  const TAG_NAME = settings.tagName;\n  const nodes = element.getElementsByTagName('*');\n  const wordsInEachLine = [];\n  let wordsInCurrentLine = [];\n  let lineOffsetY = null;\n  let elementHeight;\n  let elementWidth;\n  let contentBox;\n  let lines = [];\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n  // Cache the element's parent and next sibling (for DOM removal).\n\n  const parent = element.parentElement;\n  const nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n\n  const splitText = createFragment(); // get the computed style object for the element\n\n  const cs = window.getComputedStyle(element);\n  const align = cs.textAlign;\n  const fontSize = parseFloat(cs.fontSize);\n  const lineThreshold = fontSize * 0.2; // IF using absolute position...\n\n  if (settings.absolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: element.offsetLeft,\n      top: element.offsetTop,\n      width: element.offsetWidth\n    }; // Let elementWidth and elementHeight be the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n\n    set(element, {\n      cssWidth: element.style.width,\n      cssHeight: element.style.height\n    });\n  } // Iterate over every node in the target element\n\n  toArray(nodes).forEach(node => {\n    // node is a word element or custom html element\n    const isWordLike = node.parentElement === element; // TODO needs work\n    // Get te size and position of split text nodes\n\n    const {\n      width,\n      height,\n      top,\n      left\n    } = getPosition(node, isWordLike, settings, scrollPos); // If element is a `<br>` tag return here\n\n    if (/^br$/i.test(node.nodeName)) return;\n    if (types.lines && isWordLike) {\n      // We compare the top offset of the current word to the top offset of\n      // previous words on the current line. If the difference is greater than\n      // our defined threshold (20%), we assume this word is on a new line.\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n        lineOffsetY = top;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n      wordsInCurrentLine.push(node);\n    } // END IF\n\n    if (settings.absolute) {\n      // Store the size and position split text nodes\n      set(node, {\n        top,\n        left,\n        width,\n        height\n      });\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n  if (types.lines) {\n    // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n    lines = wordsInEachLine.map(wordsInThisLine => {\n      // Create an element to wrap the current line.\n      const lineElement = createElement(TAG_NAME, {\n        class: `${settings.splitClass} ${settings.lineClass}`,\n        style: `display: block; text-align: ${align}; width: 100%;`\n      });\n      set(lineElement, 'isLine', true);\n      const lineDimensions = {\n        height: 0,\n        top: 1e4\n      }; // Append the `lineElement` to `container`\n\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n      // Note: wordOrElement can either be a word node or nested element\n\n      wordsInThisLine.forEach((wordOrElement, idx, arr) => {\n        const {\n          isWordEnd,\n          top,\n          height\n        } = get(wordOrElement);\n        const next = arr[idx + 1]; // Determine line height / y-position\n        // we use the height and offsetTop of the words which we already\n        // recorded. Because custom nested elements could have their own\n        // styles, the words on a line may not all be the same height or\n        // y position. So we take the greatest height / y - offset of the\n        // words on this line.\n\n        lineDimensions.height = Math.max(lineDimensions.height, height);\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n        // If this is not the last word on the current line.\n        // TODO - logic for handing spacing can be improved\n\n        if (isWordEnd && get(next).isWordStart) {\n          lineElement.append(' ');\n        }\n      }); // END LOOP\n\n      if (settings.absolute) {\n        set(lineElement, {\n          height: lineDimensions.height,\n          top: lineDimensions.top\n        });\n      }\n      return lineElement;\n    }); // END LOOP\n\n    if (!types.words) {\n      unSplitWords(splitText);\n    } // 10. Insert the new container\n\n    element.replaceChildren(splitText);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all child elements of the target element.\n  // This includes split lines, words, chars, and custom HTML elements that were\n  // included by the user. The size and position of child elements has already\n  // been recorded before splitting text into lines.\n\n  if (settings.absolute) {\n    // Set the width/height of the parent element so it does not collapse\n    // when its children are set to absolute position.\n    element.style.width = `${element.style.width || elementWidth}px`;\n    element.style.height = `${elementHeight}px`; // Iterate over all child elements\n\n    toArray(nodes).forEach(node => {\n      const {\n        isLine,\n        top,\n        left,\n        width,\n        height\n      } = get(node);\n      const parentData = get(node.parentElement);\n      const isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n      // -> If `node` a line element, we use the top offset of its first child\n      // -> If `node` the child of line element, then its top offset is zero\n\n      node.style.top = `${isChildOfLineNode ? top - parentData.top : top}px`; // Set the left position of the current node.\n      // -> IF `node` is a line element, this is equal to the position left of\n      //    the content box of the parent element\n      // -> IF `node` is the child of a line element, the value has to adjusted\n      //    so its relative to the line element\n\n      node.style.left = isLine ? `${contentBox.left}px` : `${left - (isChildOfLineNode ? contentBox.left : 0)}px`; // Set the height of the current node to the cached value.\n\n      node.style.height = `${height}px`; //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLine ? `${contentBox.width}px` : `${width}px`; // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n  return lines;\n}\nlet _defaults = extend(defaults, {});\nclass SplitType {\n  /**\n   * The internal data store\n   */\n  static get data() {\n    return cache;\n  }\n  /**\n   * The default settings for all splitType instances\n   * @static\n   */\n\n  static get defaults() {\n    return _defaults;\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   *\n   * Setting `SplitType.defaults` to an object will merge that object with the\n   * existing defaults.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @deprecated\n   * @static\n   * @example\n   * SplitType.defaults = { \"position\": \"absolute\" }\n   */\n\n  static set defaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   * The provided object will be merged with the existing defaults objects.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @returns {Object} the new default settings\n   * @public\n   * @static\n   * @example\n   * SplitType.setDefaults({ \"position\": \"absolute\" })\n   */\n\n  static setDefaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n    return defaults;\n  }\n  /**\n   * Revert target elements to their original html content\n   * Has no effect on that\n   *\n   * @param {any} elements The target elements to revert. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @static\n   */\n\n  static revert(elements) {\n    getTargetElements(elements).forEach(element => {\n      const {\n        isSplit,\n        html,\n        cssWidth,\n        cssHeight\n      } = get(element);\n      if (isSplit) {\n        element.innerHTML = html;\n        element.style.width = cssWidth || '';\n        element.style.height = cssHeight || '';\n        remove(element);\n      }\n    });\n  }\n  /**\n   * Creates a new SplitType instance\n   * This static method provides a way to create a `SplitType` instance without\n   * using the `new` keyword.\n   *\n   * @param {any} target The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   * @return {SplitType} the SplitType instance\n   * @static\n   */\n\n  static create(target, options) {\n    return new SplitType(target, options);\n  }\n  /**\n   * Creates a new `SplitType` instance\n   *\n   * @param {any} elements The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   */\n\n  constructor(elements, options) {\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(elements); // Start the split process\n\n    this.split();\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n  split(options) {\n    // Revert target elements (if they are already split)\n    // Note: revert was already called once in the constructor. However, we\n    // need to call it again here so text is reverted when the user manually\n    // calls the `split` method to re-split text.\n    this.revert(); // Store the original html content of each target element\n\n    this.elements.forEach(element => {\n      set(element, 'html', element.innerHTML);\n    }); // Create arrays to hold the split lines, words, and characters\n\n    this.lines = [];\n    this.words = [];\n    this.chars = []; // cache vertical scroll position before splitting\n\n    const scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n    if (options !== undefined) {\n      this.settings = extend(this.settings, parseSettings(options));\n    }\n    const types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n    // @example new SplitType('#target', { types: [] })\n\n    if (types.none) {\n      return;\n    } // Split text in each target element\n\n    this.elements.forEach(element => {\n      // Add the split text nodes from this element to the arrays of all split\n      // text nodes for this instance.\n      set(element, 'isRoot', true);\n      const {\n        words,\n        chars\n      } = split(element, this.settings);\n      this.words = [...this.words, ...words];\n      this.chars = [...this.chars, ...chars];\n    });\n    this.elements.forEach(element => {\n      if (types.lines || this.settings.absolute) {\n        const lines = repositionAfterSplit(element, this.settings, scrollPos);\n        this.lines = [...this.lines, ...lines];\n      }\n    }); // Set isSplit to true for the SplitType instance\n\n    this.isSplit = true; // Set scroll position to cached value.\n\n    window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n\n    cleanup();\n  }\n  /**\n   * Reverts target element(s) back to their original html content\n   * Deletes all stored data associated with the target elements\n   * Resets the properties on the splitType instance\n   *\n   * @public\n   */\n\n  revert() {\n    if (this.isSplit) {\n      // Reset instance properties if necessary\n      this.lines = null;\n      this.words = null;\n      this.chars = null;\n      this.isSplit = false;\n    }\n    SplitType.revert(this.elements);\n  }\n}\nexport { SplitType as default };","map":{"version":3,"names":["append","nodes","length","i","node","nodeType","appendChild","document","createTextNode","String","replaceChildren","lastChild","removeChild","replaceWith","parent","parentNode","ownerDocument","replaceChild","insertBefore","previousSibling","Element","prototype","DocumentFragment","extend","target","object","Object","getOwnPropertyNames","reduce","extended","key","currentValue","getOwnPropertyDescriptor","newValue","defineProperty","isString","value","isArray","Array","parseSettings","settings","types","undefined","split","map","type","trim","filter","test","absolute","position","parseTypes","none","lines","words","chars","isObject","isNode","input","isLength","isArrayLike","toArray","slice","call","getTargetElements","elements","getElementById","querySelectorAll","result","element","entries","keys","values","expando","cache","uid","set","owner","console","warn","id","data","getPrototypeOf","get","remove","cleanup","forEach","isRoot","isSplit","toWords","separator","string","replace","rsAstralRange","rsComboMarksRange","rsComboSymbolsRange","rsVarRange","rsAstral","rsCombo","rsFitz","rsModifier","rsNonAstral","rsRegional","rsSurrPair","rsZWJ","reOptMod","rsOptVar","rsOptJoin","join","rsSeq","rsSymbol","reUnicode","RegExp","unicodeRange","reHasUnicode","asciiToArray","hasUnicode","unicodeToArray","match","stringToArray","toString","toChars","createElement","name","attributes","attribute","rawValue","setAttribute","defaults","splitClass","lineClass","wordClass","charClass","tagName","splitWordsAndChars","textNode","TAG_NAME","VALUE","nodeValue","splitText","createDocumentFragment","WORD","idx","arr","wordElement","characterElementsForCurrentWord","CHAR","characterElement","class","style","children","isWord","isWordStart","isWordEnd","concat","wordsAndChars","childNodes","display","nextSibling","prevSibling","text","textContent","textAfter","textBefore","child","getPosition","scrollPos","top","offsetTop","offsetParent","scrollX","scrollY","parentX","parentY","body","parentRect","getBoundingClientRect","x","y","width","height","left","unSplitWords","createFragment","repositionAfterSplit","getElementsByTagName","wordsInEachLine","wordsInCurrentLine","lineOffsetY","elementHeight","elementWidth","contentBox","parentElement","nextElementSibling","cs","window","getComputedStyle","align","textAlign","fontSize","parseFloat","lineThreshold","offsetLeft","offsetWidth","offsetHeight","cssWidth","cssHeight","isWordLike","nodeName","push","wordsInThisLine","lineElement","lineDimensions","wordOrElement","next","Math","max","min","isLine","parentData","isChildOfLineNode","_defaults","SplitType","options","setDefaults","revert","html","innerHTML","create","constructor","pageXOffset","pageYOffset","scrollTo","default"],"sources":["C:/2023/project/node_modules/split-type/dist/index.js"],"sourcesContent":["/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.3\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n// Polyfill the following DOM methods that are not supported in IE 11.\n\n(() => {\n  function append(...nodes) {\n    const length = nodes.length;\n\n    for (let i = 0; i < length; i++) {\n      const node = nodes[i];\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\n    }\n  }\n\n  function replaceChildren(...nodes) {\n    while (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n\n    if (nodes.length) this.append(...nodes);\n  }\n\n  function replaceWith(...nodes) {\n    const parent = this.parentNode;\n    let i = nodes.length;\n    if (!parent) return;\n    if (!i) parent.removeChild(this);\n\n    while (i--) {\n      let node = nodes[i];\n\n      if (typeof node !== 'object') {\n        node = this.ownerDocument.createTextNode(node);\n      } else if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n\n      if (!i) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(this.previousSibling, node);\n      }\n    }\n  }\n\n  if (typeof Element !== 'undefined') {\n    if (!Element.prototype.append) {\n      Element.prototype.append = append;\n      DocumentFragment.prototype.append = append;\n    }\n\n    if (!Element.prototype.replaceChildren) {\n      Element.prototype.replaceChildren = replaceChildren;\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\n    }\n\n    if (!Element.prototype.replaceWith) {\n      Element.prototype.replaceWith = replaceWith;\n      DocumentFragment.prototype.replaceWith = replaceWith;\n    }\n  }\n})();\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce((extended, key) => {\n    const currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    const newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings(settings = {}) {\n  const object = extend(settings); // `split` may be used as an alias for the `types` option\n  // Parse the `types` settings into an array of valid split types.\n  // If `types` is explicitly set to an empty string or array, text will not be\n  // split at all.\n\n  let types;\n\n  if (object.types !== undefined) {\n    types = object.types;\n  } else if (object.split !== undefined) {\n    types = object.split;\n  }\n\n  if (types !== undefined) {\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(type => String(type).trim()).filter(type => /((line)|(word)|(char))/i.test(type));\n  } // Support `position: absolute` as an alias for `absolute: true`\n\n\n  if (object.absolute || object.position) {\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n\n  return object;\n}\n\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  const types = isString(value) || isArray(value) ? String(value) : '';\n  return {\n    none: !types,\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /char/i.test(types)\n  };\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */\n\nfunction getTargetElements(target) {\n  let elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  } // Return a flattened array of elements\n\n\n  return toArray(elements).reduce((result, element) => {\n    return [...result, ...toArray(element).filter(isNode)];\n  }, []);\n}\n\nconst {\n  entries,\n  keys,\n  values\n} = Object;\n\nconst expando = `_splittype`;\nconst cache = {};\nlet uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */\n\nfunction set(owner, key, value) {\n  if (!isObject(owner)) {\n    console.warn('[data.set] owner is not an object');\n    return null;\n  }\n\n  const id = owner[expando] || (owner[expando] = ++uid);\n  const data = cache[id] || (cache[id] = {});\n\n  if (value === undefined) {\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n      cache[id] = { ...data,\n        ...key\n      };\n    }\n  } else if (key !== undefined) {\n    data[key] = value;\n  }\n\n  return value;\n}\nfunction get(owner, key) {\n  const id = isObject(owner) ? owner[expando] : null;\n  const data = id && cache[id] || {};\n\n  if (key === undefined) {\n    return data;\n  }\n\n  return data[key];\n}\n/**\n * Remove all data associated with the given element\n */\n\nfunction remove(element) {\n  const id = element && element[expando];\n\n  if (id) {\n    delete element[id];\n    delete cache[id];\n  }\n}\n/**\n * Remove all temporary data from the store.\n */\n\nfunction cleanup() {\n  entries(cache).forEach(([id, {\n    isRoot,\n    isSplit\n  }]) => {\n    if (!isRoot || !isSplit) {\n      cache[id] = null;\n      delete cache[id];\n    }\n  });\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(value, separator = ' ') {\n  const string = value ? String(value) : '';\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\n/** Used to compose unicode capture groups. */\n\nconst rsAstral = `[${rsAstralRange}]`;\nconst rsCombo = `[${rsComboMarksRange}${rsComboSymbolsRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsZWJ = '\\\\u200d';\n/** Used to compose unicode regexes. */\n\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsSymbol = `(?:${[`${rsNonAstral}${rsCombo}?`, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')}\n)`;\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol}${rsSeq}`, 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nconst unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nconst reHasUnicode = RegExp(`[${unicodeRange.join('')}]`);\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('f😀o');\n * // => ['f', '😀', 'o']\n *\n * toChars('f-😀-o', /-/);\n * // => ['f', '😀', 'o']\n *\n */\n\n\nfunction toChars(string, separator = '') {\n  string = toString(string);\n\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  const element = document.createElement(name);\n\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n\n  Object.keys(attributes).forEach(attribute => {\n    const rawValue = attributes[attribute];\n    const value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n\n    if (value === null || value === '') return;\n\n    if (attribute === 'children') {\n      // Children can be one or more Elements or DOM strings\n      element.append(...toArray(value));\n    } else {\n      // Handle standard HTML attributes\n      element.setAttribute(attribute, value);\n    }\n  });\n  return element;\n}\n\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: ['lines', 'words', 'chars'],\n  absolute: false,\n  tagName: 'div'\n};\n\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */\n\nfunction splitWordsAndChars(textNode, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  const types = parseTypes(settings.types); // the tag name for split text nodes\n\n  const TAG_NAME = settings.tagName; // value of the text node\n\n  const VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n\n  const splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n\n  let words = [];\n  let chars = [];\n\n  if (/^\\s/.test(VALUE)) {\n    splitText.append(' ');\n  } // Create an array of wrapped word elements.\n\n\n  words = toWords(VALUE).reduce((result, WORD, idx, arr) => {\n    // Let `wordElement` be the wrapped element for the current word\n    let wordElement;\n    let characterElementsForCurrentWord; // -> If splitting text into characters...\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      characterElementsForCurrentWord = toChars(WORD).map(CHAR => {\n        const characterElement = createElement(TAG_NAME, {\n          class: `${settings.splitClass} ${settings.charClass}`,\n          style: 'display: inline-block;',\n          children: CHAR\n        });\n        set(characterElement, 'isChar', true);\n        chars = [...chars, characterElement];\n        return characterElement;\n      });\n    } // END IF;\n\n\n    if (types.words || types.lines) {\n      // -> If Splitting Text Into Words...\n      //    Create an element to wrap the current word. If we are also\n      //    splitting text into characters, the word element will contain the\n      //    wrapped character nodes for this word. If not, it will contain the\n      //    plain text content (WORD)\n      wordElement = createElement(TAG_NAME, {\n        class: `${settings.wordClass} ${settings.splitClass}`,\n        style: `display: inline-block; ${types.words && settings.absolute ? `position: relative;` : ''}`,\n        children: types.chars ? characterElementsForCurrentWord : WORD\n      });\n      set(wordElement, {\n        isWord: true,\n        isWordStart: true,\n        isWordEnd: true\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // -> If NOT splitting into words OR lines...\n      //    Append the characters elements directly to splitText.\n      characterElementsForCurrentWord.forEach(characterElement => {\n        splitText.appendChild(characterElement);\n      });\n    }\n\n    if (idx < arr.length - 1) {\n      // Add a space after the word.\n      splitText.append(' ');\n    } // If not splitting text into words, we return an empty array\n\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // END LOOP;\n  // Add a trailing white space to maintain word spacing\n\n  if (/\\s$/.test(VALUE)) {\n    splitText.append(' ');\n  }\n\n  textNode.replaceWith(splitText);\n  return {\n    words,\n    chars\n  };\n}\n\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */\n\nfunction split(node, settings) {\n  const type = node.nodeType; // Arrays of split words and characters\n\n  const wordsAndChars = {\n    words: [],\n    chars: []\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n\n  if (!/(1|3|11)/.test(type)) {\n    return wordsAndChars;\n  } // A) IF `node` is TextNode that contains characters other than white space...\n  //    Split the text content of the node into words and/or characters\n  //    return an object containing the split word and character elements\n\n\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\n    return splitWordsAndChars(node, settings);\n  } // B) ELSE `node` is an 'Element'\n  //    Iterate through its child nodes, calling the `split` function\n  //    recursively for each child node.\n\n\n  const childNodes = toArray(node.childNodes);\n\n  if (childNodes.length) {\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\n\n    if (!get(node).isRoot) {\n      node.style.display = 'inline-block';\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\n      // splitting text into lines, we need to check if the element should\n      // have a space before and after, and store that value for later.\n      // Note: this was necessary to maintain the correct spacing when nested\n      // elements do not align with word boundaries. For example, a nested\n      // element only wraps part of a word.\n\n      const nextSibling = node.nextSibling;\n      const prevSibling = node.previousSibling;\n      const text = node.textContent || '';\n      const textAfter = nextSibling ? nextSibling.textContent : ' ';\n      const textBefore = prevSibling ? prevSibling.textContent : ' ';\n      set(node, {\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n      });\n    }\n  } // Iterate through child nodes, calling `split` recursively\n  // Returns an object containing all split words and chars\n\n\n  return childNodes.reduce((result, child) => {\n    const {\n      words,\n      chars\n    } = split(child, settings);\n    return {\n      words: [...result.words, ...words],\n      chars: [...result.chars, ...chars]\n    };\n  }, wordsAndChars);\n}\n\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */\nfunction getPosition(node, isWord, settings, scrollPos) {\n  if (!settings.absolute) {\n    return {\n      top: isWord ? node.offsetTop : null\n    };\n  }\n\n  const parent = node.offsetParent;\n  const [scrollX, scrollY] = scrollPos;\n  let parentX = 0;\n  let parentY = 0;\n\n  if (parent && parent !== document.body) {\n    const parentRect = parent.getBoundingClientRect();\n    parentX = parentRect.x + scrollX;\n    parentY = parentRect.y + scrollY;\n  }\n\n  const {\n    width,\n    height,\n    x,\n    y\n  } = node.getBoundingClientRect();\n  const top = y + scrollY - parentY;\n  const left = x + scrollX - parentX;\n  return {\n    width,\n    height,\n    top,\n    left\n  };\n}\n\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */\n\nfunction unSplitWords(element) {\n  if (!get(element).isWord) {\n    toArray(element.children).forEach(child => unSplitWords(child));\n  } else {\n    remove(element);\n    element.replaceWith(...element.childNodes);\n  }\n}\n\nconst createFragment = () => document.createDocumentFragment();\n\nfunction repositionAfterSplit(element, settings, scrollPos) {\n  const types = parseTypes(settings.types);\n  const TAG_NAME = settings.tagName;\n  const nodes = element.getElementsByTagName('*');\n  const wordsInEachLine = [];\n  let wordsInCurrentLine = [];\n  let lineOffsetY = null;\n  let elementHeight;\n  let elementWidth;\n  let contentBox;\n  let lines = [];\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n  // Cache the element's parent and next sibling (for DOM removal).\n\n  const parent = element.parentElement;\n  const nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n\n  const splitText = createFragment(); // get the computed style object for the element\n\n  const cs = window.getComputedStyle(element);\n  const align = cs.textAlign;\n  const fontSize = parseFloat(cs.fontSize);\n  const lineThreshold = fontSize * 0.2; // IF using absolute position...\n\n  if (settings.absolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: element.offsetLeft,\n      top: element.offsetTop,\n      width: element.offsetWidth\n    }; // Let elementWidth and elementHeight be the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n\n    set(element, {\n      cssWidth: element.style.width,\n      cssHeight: element.style.height\n    });\n  } // Iterate over every node in the target element\n\n\n  toArray(nodes).forEach(node => {\n    // node is a word element or custom html element\n    const isWordLike = node.parentElement === element; // TODO needs work\n    // Get te size and position of split text nodes\n\n    const {\n      width,\n      height,\n      top,\n      left\n    } = getPosition(node, isWordLike, settings, scrollPos); // If element is a `<br>` tag return here\n\n    if (/^br$/i.test(node.nodeName)) return;\n\n    if (types.lines && isWordLike) {\n      // We compare the top offset of the current word to the top offset of\n      // previous words on the current line. If the difference is greater than\n      // our defined threshold (20%), we assume this word is on a new line.\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n        lineOffsetY = top;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n\n      wordsInCurrentLine.push(node);\n    } // END IF\n\n\n    if (settings.absolute) {\n      // Store the size and position split text nodes\n      set(node, {\n        top,\n        left,\n        width,\n        height\n      });\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n\n  if (types.lines) {\n    // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n    lines = wordsInEachLine.map(wordsInThisLine => {\n      // Create an element to wrap the current line.\n      const lineElement = createElement(TAG_NAME, {\n        class: `${settings.splitClass} ${settings.lineClass}`,\n        style: `display: block; text-align: ${align}; width: 100%;`\n      });\n      set(lineElement, 'isLine', true);\n      const lineDimensions = {\n        height: 0,\n        top: 1e4\n      }; // Append the `lineElement` to `container`\n\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n      // Note: wordOrElement can either be a word node or nested element\n\n      wordsInThisLine.forEach((wordOrElement, idx, arr) => {\n        const {\n          isWordEnd,\n          top,\n          height\n        } = get(wordOrElement);\n        const next = arr[idx + 1]; // Determine line height / y-position\n        // we use the height and offsetTop of the words which we already\n        // recorded. Because custom nested elements could have their own\n        // styles, the words on a line may not all be the same height or\n        // y position. So we take the greatest height / y - offset of the\n        // words on this line.\n\n        lineDimensions.height = Math.max(lineDimensions.height, height);\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n        // If this is not the last word on the current line.\n        // TODO - logic for handing spacing can be improved\n\n        if (isWordEnd && get(next).isWordStart) {\n          lineElement.append(' ');\n        }\n      }); // END LOOP\n\n      if (settings.absolute) {\n        set(lineElement, {\n          height: lineDimensions.height,\n          top: lineDimensions.top\n        });\n      }\n\n      return lineElement;\n    }); // END LOOP\n\n    if (!types.words) {\n      unSplitWords(splitText);\n    } // 10. Insert the new container\n\n\n    element.replaceChildren(splitText);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all child elements of the target element.\n  // This includes split lines, words, chars, and custom HTML elements that were\n  // included by the user. The size and position of child elements has already\n  // been recorded before splitting text into lines.\n\n\n  if (settings.absolute) {\n    // Set the width/height of the parent element so it does not collapse\n    // when its children are set to absolute position.\n    element.style.width = `${element.style.width || elementWidth}px`;\n    element.style.height = `${elementHeight}px`; // Iterate over all child elements\n\n    toArray(nodes).forEach(node => {\n      const {\n        isLine,\n        top,\n        left,\n        width,\n        height\n      } = get(node);\n      const parentData = get(node.parentElement);\n      const isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n      // -> If `node` a line element, we use the top offset of its first child\n      // -> If `node` the child of line element, then its top offset is zero\n\n      node.style.top = `${isChildOfLineNode ? top - parentData.top : top}px`; // Set the left position of the current node.\n      // -> IF `node` is a line element, this is equal to the position left of\n      //    the content box of the parent element\n      // -> IF `node` is the child of a line element, the value has to adjusted\n      //    so its relative to the line element\n\n      node.style.left = isLine ? `${contentBox.left}px` : `${left - (isChildOfLineNode ? contentBox.left : 0)}px`; // Set the height of the current node to the cached value.\n\n      node.style.height = `${height}px`; //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLine ? `${contentBox.width}px` : `${width}px`; // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n\n  return lines;\n}\n\nlet _defaults = extend(defaults, {});\n\nclass SplitType {\n  /**\n   * The internal data store\n   */\n  static get data() {\n    return cache;\n  }\n  /**\n   * The default settings for all splitType instances\n   * @static\n   */\n\n\n  static get defaults() {\n    return _defaults;\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   *\n   * Setting `SplitType.defaults` to an object will merge that object with the\n   * existing defaults.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @deprecated\n   * @static\n   * @example\n   * SplitType.defaults = { \"position\": \"absolute\" }\n   */\n\n\n  static set defaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   * The provided object will be merged with the existing defaults objects.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @returns {Object} the new default settings\n   * @public\n   * @static\n   * @example\n   * SplitType.setDefaults({ \"position\": \"absolute\" })\n   */\n\n\n  static setDefaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n    return defaults;\n  }\n  /**\n   * Revert target elements to their original html content\n   * Has no effect on that\n   *\n   * @param {any} elements The target elements to revert. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @static\n   */\n\n\n  static revert(elements) {\n    getTargetElements(elements).forEach(element => {\n      const {\n        isSplit,\n        html,\n        cssWidth,\n        cssHeight\n      } = get(element);\n\n      if (isSplit) {\n        element.innerHTML = html;\n        element.style.width = cssWidth || '';\n        element.style.height = cssHeight || '';\n        remove(element);\n      }\n    });\n  }\n  /**\n   * Creates a new SplitType instance\n   * This static method provides a way to create a `SplitType` instance without\n   * using the `new` keyword.\n   *\n   * @param {any} target The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   * @return {SplitType} the SplitType instance\n   * @static\n   */\n\n\n  static create(target, options) {\n    return new SplitType(target, options);\n  }\n  /**\n   * Creates a new `SplitType` instance\n   *\n   * @param {any} elements The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   */\n\n\n  constructor(elements, options) {\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(elements); // Start the split process\n\n    this.split();\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n\n  split(options) {\n    // Revert target elements (if they are already split)\n    // Note: revert was already called once in the constructor. However, we\n    // need to call it again here so text is reverted when the user manually\n    // calls the `split` method to re-split text.\n    this.revert(); // Store the original html content of each target element\n\n    this.elements.forEach(element => {\n      set(element, 'html', element.innerHTML);\n    }); // Create arrays to hold the split lines, words, and characters\n\n    this.lines = [];\n    this.words = [];\n    this.chars = []; // cache vertical scroll position before splitting\n\n    const scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n    if (options !== undefined) {\n      this.settings = extend(this.settings, parseSettings(options));\n    }\n\n    const types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n    // @example new SplitType('#target', { types: [] })\n\n    if (types.none) {\n      return;\n    } // Split text in each target element\n\n\n    this.elements.forEach(element => {\n      // Add the split text nodes from this element to the arrays of all split\n      // text nodes for this instance.\n      set(element, 'isRoot', true);\n      const {\n        words,\n        chars\n      } = split(element, this.settings);\n      this.words = [...this.words, ...words];\n      this.chars = [...this.chars, ...chars];\n    });\n    this.elements.forEach(element => {\n      if (types.lines || this.settings.absolute) {\n        const lines = repositionAfterSplit(element, this.settings, scrollPos);\n        this.lines = [...this.lines, ...lines];\n      }\n    }); // Set isSplit to true for the SplitType instance\n\n    this.isSplit = true; // Set scroll position to cached value.\n\n    window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n\n    cleanup();\n  }\n  /**\n   * Reverts target element(s) back to their original html content\n   * Deletes all stored data associated with the target elements\n   * Resets the properties on the splitType instance\n   *\n   * @public\n   */\n\n\n  revert() {\n    if (this.isSplit) {\n      // Reset instance properties if necessary\n      this.lines = null;\n      this.words = null;\n      this.chars = null;\n      this.isSplit = false;\n    }\n\n    SplitType.revert(this.elements);\n  }\n\n}\n\nexport { SplitType as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}